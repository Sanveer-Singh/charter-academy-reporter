# Feature Implementation Phase Rules

## Critical Rules

### RULE 1: Plan Adherence
- **MUST**: Follow the approved implementation plan exactly
- **MUST**: Complete tasks in planned order
- **MUST**: Update workflow state before each task
- **ALWAYS**: Document any necessary deviations
- **NEVER**: Add unplanned functionality

### RULE 2: Test-Driven Implementation
- **MUST**: Write tests BEFORE implementation code
- **MUST**: Ensure tests fail before implementation
- **MUST**: Make tests pass with minimal code
- **ALWAYS**: Refactor after tests pass
- **NEVER**: Skip the red-green-refactor cycle

### RULE 3: Code Quality Standards
- **MUST**: Follow @implementation-rules.mdc#Naming Standards
- **MUST**: Keep methods under 20 lines
- **MUST**: Maintain cyclomatic complexity < 10
- **ALWAYS**: Use meaningful variable names
- **NEVER**: Leave commented code

### RULE 4: Architecture Enforcement
- **MUST**: Maintain clean layer separation
- **MUST**: Use dependency injection
- **MUST**: Keep controllers thin
- **ALWAYS**: Put business logic in services
- **NEVER**: Skip repository pattern

### RULE 5: Security Implementation
- **MUST**: Validate ALL inputs server-side
- **MUST**: Use parameterized queries exclusively
- **MUST**: Implement proper authentication/authorization
- **ALWAYS**: Encode outputs to prevent XSS
- **NEVER**: Trust client-side data

### RULE 6: Performance Standards
- **MUST**: Use async/await for I/O operations
- **MUST**: Implement planned caching strategies
- **MUST**: Optimize database queries
- **ALWAYS**: Use pagination for lists
- **NEVER**: Load unnecessary data

### RULE 7: UI Implementation
- **MUST**: Mobile-first responsive design
- **MUST**: WCAG 2.1 AA compliance
- **MUST**: Semantic HTML structure
- **ALWAYS**: Use CSS variables for theming
- **NEVER**: Use inline styles

### RULE 8: Code Cleanup
- **MUST**: Remove all debug code
- **MUST**: Delete commented code blocks
- **MUST**: Remove unused imports
- **MUST**: Update deprecated code references
- **ALWAYS**: Run code formatters
- **NEVER**: Leave TODO comments

### RULE 9: Build Verification
- **MUST**: Ensure zero build errors
- **MUST**: Fix all warnings in new code
- **MUST**: Run SonarScan and fix issues
- **ALWAYS**: Test in multiple browsers
- **NEVER**: Commit breaking builds

### RULE 10: Documentation
- **MUST**: Add XML comments to public methods
- **MUST**: Document complex algorithms
- **MUST**: Update API documentation
- **ALWAYS**: Include usage examples
- **NEVER**: Leave public APIs undocumented

## Implementation Execution Checklist
✓ Task started per plan
✓ Tests written first
✓ Tests fail initially
✓ Implementation makes tests pass
✓ Code refactored for quality
✓ Architecture patterns followed
✓ Security measures implemented
✓ Performance optimized
✓ UI responsive and accessible
✓ Code cleaned up
✓ Build successful
✓ Documentation complete
✓ Task marked complete

## Task Implementation Template
```markdown
## Task: [Task Name from Plan]
Started: YYYY-MM-DD HH:MM
Status: In Progress

### Tests Created
- [ ] Unit test: [TestName] - Red
- [ ] Integration test: [TestName] - Red

### Implementation Steps
- [ ] Create/modify model
- [ ] Implement repository method
- [ ] Add service logic
- [ ] Update controller
- [ ] Create UI component

### Code Review Checklist
- [ ] SOLID principles followed
- [ ] Security validated
- [ ] Performance optimized
- [ ] Accessibility verified
- [ ] Documentation added

### Completion
- Tests: All Green ✅
- Build: Success ✅
- SonarScan: Clean ✅
Completed: YYYY-MM-DD HH:MM
```

## Common Implementation Patterns

### Repository Implementation
```csharp
public async Task<IEnumerable<DashboardData>> GetFilteredDataAsync(
    DashboardFilter filter, 
    string userId)
{
    return await _context.DashboardData
        .Where(d => d.UserId == userId)
        .Where(ApplyFilters(filter))
        .OrderBy(d => d.Date)
        .Take(filter.Limit ?? 100)
        .AsNoTracking()
        .ToListAsync();
}
```

### Service Implementation
```csharp
public async Task<ServiceResult<DashboardResponse>> GetFilteredDashboardAsync(
    DashboardFilterRequest request)
{
    try
    {
        // Validate
        if (!await _validator.ValidateAsync(request))
            return ServiceResult<DashboardResponse>.Failure("Invalid request");
            
        // Check permissions
        if (!await _authService.CanAccessDashboard(request.UserId))
            return ServiceResult<DashboardResponse>.Unauthorized();
            
        // Get data
        var data = await _repository.GetFilteredDataAsync(
            request.ToFilter(), 
            request.UserId);
            
        // Transform and return
        return ServiceResult<DashboardResponse>.Success(
            new DashboardResponse { Data = data });
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Dashboard filter failed");
        return ServiceResult<DashboardResponse>.Failure("Unable to process request");
    }
}
```

### Controller Implementation
```csharp
[HttpPost("filter")]
[Authorize]
public async Task<IActionResult> FilterDashboard(
    [FromBody] DashboardFilterRequest request)
{
    if (!ModelState.IsValid)
        return BadRequest(ModelState);
        
    var result = await _dashboardService.GetFilteredDashboardAsync(request);
    
    return result.Success 
        ? Ok(result.Data)
        : HandleServiceError(result);
}
```

### UI Component Implementation
```javascript
// dashboard-filter.js
class DashboardFilter {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.initializeEventHandlers();
        this.loadSavedFilters();
    }
    
    async applyFilters() {
        const filters = this.collectFilters();
        if (!this.validateFilters(filters)) return;
        
        try {
            const response = await fetch('/api/dashboard/filter', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(filters)
            });
            
            if (response.ok) {
                const data = await response.json();
                this.updateDashboard(data);
            } else {
                this.handleError(response);
            }
        } catch (error) {
            this.showError('Network error occurred');
        }
    }
}
```

## Clean Code Examples

### Early Return Pattern
```csharp
public async Task<bool> ValidateOrderAsync(Order order)
{
    if (order == null)
        return false;
        
    if (order.Items?.Any() != true)
        return false;
        
    if (order.TotalAmount <= 0)
        return false;
        
    return await _inventoryService.CheckAvailabilityAsync(order.Items);
}
```

### Helper Method Extraction
```csharp
public async Task<OrderResult> ProcessOrderAsync(OrderRequest request)
{
    var validationResult = await ValidateOrderRequestAsync(request);
    if (!validationResult.IsValid)
        return OrderResult.ValidationFailure(validationResult.Errors);
        
    var order = await CreateOrderFromRequestAsync(request);
    var inventoryResult = await ReserveInventoryAsync(order);
    if (!inventoryResult.Success)
        return OrderResult.InventoryFailure(inventoryResult.Message);
        
    var savedOrder = await SaveOrderAsync(order);
    await SendOrderConfirmationAsync(savedOrder);
    
    return OrderResult.Success(savedOrder);
}
```

### Async/Await Best Practices
```csharp
// GOOD: Proper async all the way
public async Task<IActionResult> GetOrdersAsync()
{
    var orders = await _orderService.GetOrdersAsync();
    return Ok(orders);
}

// BAD: Blocking async code
public IActionResult GetOrders()
{
    var orders = _orderService.GetOrdersAsync().Result; // NEVER DO THIS
    return Ok(orders);
}
```

## CSS Implementation Standards
```css
/* Mobile-first approach */
.dashboard-filter {
    padding: 1rem;
    background: var(--filter-bg-color);
}

/* Tablet and up */
@media (min-width: 768px) {
    .dashboard-filter {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 1rem;
    }
}

/* Desktop */
@media (min-width: 1024px) {
    .dashboard-filter {
        grid-template-columns: repeat(4, 1fr);
    }
}

/* Accessibility */
.filter-input:focus {
    outline: 2px solid var(--focus-color);
    outline-offset: 2px;
}

/* High contrast mode support */
@media (prefers-contrast: high) {
    .filter-input {
        border-width: 2px;
    }
}
```

## Common Implementation Pitfalls
- ❌ Writing implementation before tests
- ❌ Skipping error handling
- ❌ Hardcoding values instead of config
- ❌ Mixing concerns in single method
- ❌ Ignoring async best practices
- ❌ Forgetting mobile responsiveness
- ❌ Missing accessibility features
- ❌ Leaving debug code in place