---
description: Mandatory SOLID principles and clean architecture patterns
alwaysApply: false
---

# SOLID Principles & Clean Architecture Rules

## Critical Rules

### RULE 1: Single Responsibility (SRP)
- **MUST**: Each class has ONE reason to change
- **MUST**: Each method does ONE thing only
- **MUST**: Delegate secondary concerns to other services
- **ALWAYS**: Use dependency injection for dependencies
- **NEVER**: Mix business logic with infrastructure

### RULE 2: Open/Closed Principle (OCP)
- **MUST**: Extend behavior through new classes, not modification
- **MUST**: Use interfaces for extensibility points
- **MUST**: Preserve existing working code
- **ALWAYS**: Add new implementations for new features
- **NEVER**: Modify existing tested classes

### RULE 3: Liskov Substitution (LSP)
- **MUST**: Derived classes fully replace base classes
- **MUST**: Maintain expected behavior contracts
- **MUST**: Throw same exceptions as base
- **ALWAYS**: Honor base class invariants
- **NEVER**: Return null if base doesn't

### RULE 4: Interface Segregation (ISP)
- **MUST**: Create small, focused interfaces
- **MUST**: Split fat interfaces into role-specific ones
- **MUST**: Client depends only on methods it uses
- **ALWAYS**: Prefer multiple specific interfaces
- **NEVER**: Force unnecessary dependencies

### RULE 5: Dependency Inversion (DIP)
- **MUST**: Depend on abstractions, not concretions
- **MUST**: Inject dependencies through constructor
- **MUST**: High-level modules define interfaces
- **ALWAYS**: Use interfaces for external dependencies
- **NEVER**: New up dependencies inside classes

### RULE 6: Clean Architecture Layers
- **MUST**: Maintain strict layer separation
- **MUST**: Dependencies point inward only
- **MUST**: Domain layer has zero dependencies
- **ALWAYS**: Keep business logic in services
- **NEVER**: Reference infrastructure from domain

### RULE 7: Repository Pattern
- **MUST**: All data access through repositories
- **MUST**: Return domain entities, not DB entities
- **MUST**: Keep queries in repository only
- **ALWAYS**: Use async operations
- **NEVER**: Expose IQueryable from repository

### RULE 8: Service Layer
- **MUST**: All business logic in services
- **MUST**: Services orchestrate, not implement
- **MUST**: Return result objects with status
- **ALWAYS**: Handle exceptions gracefully
- **NEVER**: Access database directly

### RULE 9: Domain Design
- **MUST**: Keep entities free of framework dependencies
- **MUST**: Implement value objects for complex types
- **MUST**: Use domain events for cross-aggregate communication
- **ALWAYS**: Validate invariants in entities
- **NEVER**: Put persistence logic in domain

### RULE 10: Composition Patterns
- **MUST**: Prefer composition over inheritance
- **MUST**: Use strategy pattern for varying behavior
- **MUST**: Implement factory pattern for complex creation
- **ALWAYS**: Inject behavior through interfaces
- **NEVER**: Create deep inheritance hierarchies

## Architecture Checklist
✓ One class, one responsibility
✓ Interfaces for extensions
✓ Substitutable implementations
✓ Small, focused interfaces
✓ Constructor injection used
✓ Clean layer separation
✓ Repository pattern implemented
✓ Business logic in services
✓ Domain logic in entities
✓ Composition over inheritance

## Layer Dependencies
```
Domain → (nothing)
Application → Domain
Infrastructure → Application, Domain
Presentation → Application
NEVER: Domain → Infrastructure
NEVER: Presentation → Domain
NEVER: Application → Infrastructure
```

## SOLID Quick Reference
```
SRP: One reason to change
OCP: Extend, don't modify
LSP: Substitutable behavior
ISP: Small interfaces
DIP: Depend on abstractions
```

## Pattern Quick Reference
```
Repository: Data access abstraction
Service: Business orchestration
Factory: Complex object creation
Strategy: Interchangeable algorithms
Observer: Event-driven communication
```

## Common Violations to Avoid
- God classes doing everything
- Modifying working code for features
- Breaking behavior expectations
- Fat interfaces with 10+ methods
- Direct database access in services
- Business logic in controllers
- Domain depending on infrastructure
- Anemic domain models
- Service layer doing data access