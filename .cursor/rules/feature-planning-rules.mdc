# Feature Implementation Planning Phase Rules

## Critical Rules

### RULE 1: Test-First Planning
- **MUST**: Define unit tests based on acceptance criteria FIRST
- **MUST**: Create integration test scenarios for user journeys
- **MUST**: Include edge case test definitions
- **ALWAYS**: Map tests to specific acceptance criteria
- **NEVER**: Plan implementation before test strategy

### RULE 2: Task Atomization
- **MUST**: Break feature into atomic, single-responsibility tasks
- **MUST**: Each task completable in 2-4 hours
- **MUST**: Define clear completion criteria per task
- **ALWAYS**: Order tasks by dependency
- **NEVER**: Create tasks spanning multiple layers

### RULE 3: Architecture Adherence
- **MUST**: Apply @solid-architecture.mdc principles to each task
- **MUST**: Maintain clean layer separation
- **MUST**: Use repository pattern for data access
- **ALWAYS**: Keep business logic in service layer
- **NEVER**: Violate established patterns

### RULE 4: Security Planning
- **MUST**: Plan input validation for EVERY user input
- **MUST**: Define authorization checks per endpoint
- **MUST**: Plan parameterized queries for data access
- **ALWAYS**: Reference @security-rules.mdc#OWASP
- **NEVER**: Defer security to implementation

### RULE 5: UI/UX Constraint Planning
- **MUST**: Plan for mobile-first responsive design
- **MUST**: Define accessibility requirements per component
- **MUST**: Maintain SB Admin2 theme consistency
- **ALWAYS**: Plan keyboard navigation paths
- **NEVER**: Compromise WCAG 2.1 AA standards

### RULE 6: Integration Planning
- **MUST**: Define integration points clearly
- **MUST**: Plan data transformation logic
- **MUST**: Consider async operation needs
- **ALWAYS**: Plan error handling strategies
- **NEVER**: Assume happy path only

### RULE 7: Performance Planning
- **MUST**: Identify potential bottlenecks
- **MUST**: Plan caching strategies
- **MUST**: Define query optimization needs
- **ALWAYS**: Consider pagination for lists
- **NEVER**: Load unnecessary data

### RULE 8: Risk Management
- **MUST**: Create mitigation plan for each identified risk
- **MUST**: Define rollback procedures
- **MUST**: Plan feature toggles if applicable
- **ALWAYS**: Consider database migration safety
- **NEVER**: Ignore identified risks

### RULE 9: Code Reusability Planning
- **MUST**: Reference components from analysis phase
- **MUST**: Plan enhancements to existing code
- **MUST**: Define what gets deprecated
- **ALWAYS**: Favor composition patterns
- **NEVER**: Plan duplicate functionality

### RULE 10: Critical Plan Review
- **MUST**: Validate plan against feature requirements
- **MUST**: Ensure NO scope creep
- **MUST**: Verify architectural compliance
- **ALWAYS**: Check for missing edge cases
- **NEVER**: Add "nice-to-have" features

## Planning Document Template
```markdown
# Feature Implementation Plan: [Feature Name]
Date: YYYY-MM-DD
Planner: [Agent Name]
State: RULE_WF_PHASE_FEATURE_PLANNING
References: FeatureAnalysis_YYYYMMDD_HHMM_FeatureName.md

## 1. Test Strategy

### Unit Tests
```csharp
// Service Layer Tests
[TestMethod] CreateDashboardFilter_ValidRole_ReturnsFilteredData
[TestMethod] CreateDashboardFilter_InvalidRole_ThrowsUnauthorizedException
[TestMethod] CreateDashboardFilter_NullInput_ThrowsArgumentNullException
```

### Integration Tests
```csharp
// API Tests
[TestMethod] POST_DashboardFilter_AdminRole_Returns200WithData
[TestMethod] POST_DashboardFilter_StudentRole_Returns403Forbidden
[TestMethod] GET_FilteredDashboard_ValidFilter_ReturnsFilteredResults
```

### Edge Cases
- Empty result sets
- Maximum date ranges
- Concurrent access
- Invalid filter combinations

## 2. Task Breakdown

### Task 1: Create Filter Model and DTOs
**Layer**: Models
**Time**: 2 hours
**Dependencies**: None
**Details**:
- Create DashboardFilter model
- Create request/response DTOs
- Add validation attributes
**Files**: 
- Models/DashboardFilter.cs
- DTOs/DashboardFilterRequest.cs
- DTOs/DashboardFilterResponse.cs

### Task 2: Implement Repository Layer
**Layer**: Data/Repositories
**Time**: 3 hours
**Dependencies**: Task 1
**Details**:
- Extend IDashboardRepository
- Implement filtered query methods
- Use async operations
- Include pagination
**Files**:
- Repositories/IDashboardRepository.cs
- Repositories/DashboardRepository.cs

### Task 3: Create Service Layer Logic
**Layer**: Services
**Time**: 4 hours
**Dependencies**: Task 2
**Details**:
- Implement filter orchestration
- Add role-based logic
- Cache frequently used filters
- Handle errors gracefully
**Files**:
- Services/IDashboardService.cs
- Services/DashboardService.cs

### Task 4: Update Controller
**Layer**: Controllers
**Time**: 2 hours
**Dependencies**: Task 3
**Details**:
- Add filter endpoints
- Use BaseController security
- Return proper HTTP codes
- Add Swagger documentation
**Files**:
- Controllers/DashboardController.cs

### Task 5: Create UI Components
**Layer**: Views/Frontend
**Time**: 4 hours
**Dependencies**: Task 4
**Details**:
- Create filter UI component
- Implement responsive design
- Add accessibility features
- Wire up AJAX calls
**Files**:
- Views/Dashboard/Partials/_FilterComponent.cshtml
- wwwroot/js/dashboard-filter.js
- wwwroot/css/components/dashboard-filter.css

## 3. Architecture Compliance

### SOLID Principles Applied
- **SRP**: Each service method has one responsibility
- **OCP**: Filter strategies extensible via interface
- **LSP**: All filters implement IFilterStrategy
- **ISP**: Separate interfaces for read/write operations
- **DIP**: Controllers depend on service interfaces

### Clean Architecture
```
Controller → IService → Service → IRepository → Repository → Database
                ↓
            FilterStrategy
```

## 4. Security Implementation

### Input Validation
- Server-side validation on all filter parameters
- Whitelist allowed filter fields
- Sanitize date ranges
- Validate role permissions

### Authorization
- Role check in BaseController
- Service-level permission validation
- Data-level filtering by role

## 5. Performance Optimization

### Caching Strategy
- Cache filter definitions (5 min)
- Cache common query results (1 min)
- Use memory cache for session filters

### Query Optimization
- Use indexes on filter columns
- Implement pagination
- Use AsNoTracking() for reads
- Batch related queries

## 6. Risk Mitigation

### Risk: Complex filter combinations slow queries
**Mitigation**: 
- Limit filter complexity
- Add query timeout
- Implement result caching

### Risk: Breaking existing dashboard
**Mitigation**:
- Feature toggle for new filters
- Backwards compatibility mode
- Comprehensive regression tests

## 7. Rollback Plan
1. Feature toggle to disable
2. Database migration rollback script
3. Cache invalidation procedure
4. User notification template

## 8. Dependencies to Update
- Existing dashboard views
- Navigation menu
- User preferences service
- Audit logging service

## 9. Deprecation Plan
- Mark old filter methods obsolete
- Migration guide for consumers
- Remove in version X+2
```

## Task Planning Guidelines

### Task Sizing
- Atomic: Single file/component
- Small: 1-2 hours
- Medium: 2-4 hours  
- Large: Break down further

### Task Dependencies
```
Data Models → Repository → Service → Controller → UI
     ↓           ↓           ↓          ↓        ↓
   Tests      Tests       Tests      Tests    Tests
```

### Task Naming Convention
```
[Layer]: [Action] [Component] [Modifier]
Examples:
- "Service: Create FilterService with role validation"
- "UI: Add responsive filter component"
- "Repository: Implement paginated filter queries"
```

## Common Planning Patterns

### CRUD Operations
1. Models and validation
2. Repository CRUD methods
3. Service orchestration
4. Controller endpoints
5. UI forms and grids
6. Tests at each layer

### Dashboard Features
1. Data aggregation models
2. Repository query methods
3. Service calculation logic
4. Controller data endpoints
5. UI visualization components
6. Performance optimization

### Integration Features
1. External service interfaces
2. Data mapping models
3. Service integration logic
4. Error handling strategies
5. Retry mechanisms
6. Circuit breaker patterns

## Planning Anti-Patterns
- ❌ Vague task descriptions
- ❌ Tasks spanning multiple layers
- ❌ Missing test definitions
- ❌ Ignoring performance impacts
- ❌ No rollback strategy
- ❌ Scope creep acceptance
- ❌ Security as afterthought